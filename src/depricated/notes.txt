        // // message
        // std::cout << "--> " << comm->me << " reading surf file\n";
        
        // // init vars for use later
        // std::string line; std::vector<std::string> v;
        // std::ifstream file;

        // // opening the file
        // file.open(this->twall_file);
        // if (!file.is_open()) error->all(FLERR, "twall_file did not open");

        // // boolean for reading file
        // bool go = false;

        // // used as an index counter
        // int index = 0;

        // // reading the file
        // while (file) {
        //     // getting the latest line
        //     std::getline(file, line);

        //     // trimming whitespaces off of the line
        //     boost::algorithm::trim(line);
            
        //     // filters empty lines
        //     if (!(line.length())) continue;

        //     // splitting the line at spaces
        //     boost::split(v, line, boost::is_any_of(" "));
            
        //     // gets the data from the files
        //     switch (this->file_format_flag) {
        //         case 0: // handles elmer format
        //             // if good to record data and the line only has one thing in it
        //             if (go && v.size() == 1) {
        //                 // error catching
        //                 if (index >= nlocal) error->all(FLERR, "Index exceed bounds");
                        
        //                 // adding the data to the class list 
        //                 this->twall[index] = std::stod(v[0]);
        //                 index++;
        //             } else {
        //                 // start looking for data after a line that starts with "Perm"
        //                 go = (v[0] == (std::string)"Perm:");
        //             }
        //             break;
                
        //         case 1: // sparta file
        //             // if good to record data
        //             if (go && v.size() == 2) {
        //                 // adding the data to the class array, position in array is first value in array
        //                 this->twall[std::stoi(v[0])-1] = std::stod(v[1]);
        //             } else {
        //                 // catches when the "surfs" section of the file starts
        //                 if (v.size() >= 2) go = (v[1] == (std::string)"SURFS");
        //             }
        //             break;
        //     }
        // }

    this->print("Setting up fix fea:", false);
    
    // checking if the number of args is correct
    if (narg > 12) error->all(FLERR,"Illegal fix fea command, too many inputs");
    else if (narg < 12) error->all(FLERR,"Illegal fix fea command, too few inputs");

    // making sure there is a surface to analyze
    if (!surf->exist) error->all(FLERR,"Illegal fix fea command, no surface to analyze");

    // getting when to run from the args to this fix command, nevery
    this->nevery = atoi(arg[2]);
    if (this->nevery <= 0) error->all(FLERR,"Illegal fix fea command, nevery <= 0");
    this->print("running every: " + std::to_string(this->nevery) + " steps");

    // getting the executable and file path from the args passed to this command
    char* exe_path = arg[3];
    char* sif_path = arg[4];

    // Structure which would store the metadata
    struct stat sb;

    // Calls the function with path as argument
    // If the file/directory exists at the path returns 0
    // If block executes if path exists
    if (!(stat(exe_path,  &sb) == 0))
        error->all(FLERR,"Illegal fix fea command, exe path does not exist");
    this->print("Elmer exe path: " + std::string(exe_path));

    if (!(stat(sif_path,  &sb) == 0))
        error->all(FLERR,"Illegal fix fea command, sif path does not exist");
    this->print("sif file path: " + std::string(sif_path));

    // command style: compute id surf group-id mix-id args
    char* compute_args[COMPUTE_SURF_ARGS_SIZE] = {
        (char*)"CCCC",
        (char*)"surf",
               arg[5],
               arg[6],
        (char*)"etot"
    };

    // adding the needed compute
    modify->add_compute(COMPUTE_SURF_ARGS_SIZE, compute_args);

    // char* fix_ave_args[4] = {
    //     (char*)"AAAA",
    //     (char*)"ave/surf",
    //            arg[5],
    //     (char*)"1"
    // }

    // modify->add_fix();

    // the compute index, it was just made so it is the number of computes minus 1 because it is an index
    icompute = modify->ncompute - 1;// modify->find_compute(id_qw);

    this->print("added surf compute with id: " + std::string(modify->compute[icompute]->id));

    /********  start temperature stuff  **********/

    // making sure the surface is the correct type
    if (surf->implicit)
        error->all(FLERR,"Cannot use fix fea with implicit surfs");
    if (surf->distributed)
        error->all(FLERR,"Cannot use fix fea with distributed surfs");

    // get the surface group
    int igroup = surf->find_group(arg[5]);
    if (igroup < 0)
        error->all(FLERR,"Fix fea group ID does not exist");
    
    groupbit = surf->bitmask[igroup];

    source = COMPUTE;
    // int n = strlen(arg[4]);
    // id_qw = new char[n];
    // strcpy(id_qw,&arg[4][2]);

    // char *ptr = strchr(id_qw,'[');
    // if (ptr) {
    //     if (id_qw[strlen(id_qw)-1] != ']')
    //         error->all(FLERR,"Invalid source in fix fea command");
    //     qwindex = atoi(ptr+1);
    //     *ptr = '\0';
    // } else
    
    // setting to 1 because the compute create above only has one compute value, namely etot
    qwindex = 1;

    // error checks
    cqw = modify->compute[icompute];
    if (icompute < 0)
        error->all(FLERR,"Could not find fix fea compute ID");
    if (cqw->per_surf_flag == 0)
        error->all(FLERR,"Fix fea compute does not compute per-surf info");
    if (qwindex == 0 && cqw->size_per_surf_cols > 0)
        error->all(FLERR,"Fix fea compute does not compute per-surf vector");
    if (qwindex > 0 && cqw->size_per_surf_cols == 0)
        error->all(FLERR,"Fix fea compute does not compute per-surf array");
    if (qwindex > 0 && qwindex > cqw->size_per_surf_cols)
        error->all(FLERR,"Fix fea compute array is accessed out-of-range");

    // getting the wall temperature file
    this->twall_file = arg[7];

    // if the twall file does not exist
    if (!(stat(twall_file,  &sb) == 0))
        error->all(FLERR,"Illegal fix fea command, twall_file does not exist");
    this->print("Surf temperature file path: " + std::string(twall_file));
    this->data_file = std::string(this->twall_file);

    // getting the surface emissivity
    emi = input->numeric(FLERR,arg[9]);
    if (emi <= 0.0 || emi > 1.0)
        error->all(FLERR,"Fix fea emissivity must be > 0.0 and <= 1");

    // parsing the file format, should be either elmer or sparta
    if (strcmp(arg[8],"elmer") == 0) {
        this->file_format_flag = 0;
    // } else if (strcmp(arg[8],"sparta") == 0) {
    //     this->file_format_flag = 1;
    } else {
        error->all(FLERR, "Fix fea temperature file format must be elmer or sparta");
    }
    this->print("Surf temperature file format: " + std::string(arg[8]));

    // getting the variable name to create
    int n = strlen(arg[10]) + 1;
    char *id_custom = new char[n];
    strcpy(id_custom,arg[10]);

    std::string surf_var_id = std::string(id_custom);

    // create per-surf temperature vector
    tindex = surf->add_custom(id_custom,DOUBLE,0);
    this->print("Created temperature variable: " + std::string(id_custom));
    delete [] id_custom;

    // prefactor and threshold in Stefan/Boltzmann equation
    // units of prefactor (SI) is K^4 / (watt - m^2)
    // same in 3d vs 2d, since SPARTA treats 2d cell volume as 1 m in z
    int dimension = domain->dimension;

    // setting variables based on unit system
    if (strcmp(update->unit_style,"si") == 0) {
        prefactor = 1.0 / (emi * SB_SI);
        threshold = 1.0e-6;
    } else if (strcmp(update->unit_style,"cgs") == 0) {
        prefactor = 1.0 / (emi * SB_CGS);
        threshold = 1.0e-3;
    }

    // trigger setup of list of owned surf elements belonging to surf group
    firstflag = 1;

    // initialize data structure
    tvector_me = NULL;

    // if the main process, read the file
    if (comm->me == 0) this->file_handler = true;

    // getting number of processes
    MPI_Comm_size(world, &nprocs);

    /********  end temperature stuff  **********/
    
    // command style: 
    char* surf_collide_args[4] = {
        (char*)"SSSS",
        (char*)"diffuse",
        (char*)("s_" + surf_var_id).c_str(),
        (char*)"0.5"
    };

    // adding surf collision model needed
    this->surf->add_collide(4, surf_collide_args);

    // command style: 
    char* surf_modify_args[3] = {
        (char*)"all",
        (char*)"collide",
        (char*)"SSSS"
    };

    // modifying params
    this->surf->modify_params(3, surf_modify_args);

    // getting the mesh database path stem from the args
    this->file_stem = std::string(arg[11]);
    this->print("Checking mesh database at: " + file_stem);
    
    // making sure all of the component files are a part of the database
    std::string exts[4] = {"boundary", "nodes", "header", "elements"}; // list of component file extensions
    for (int i = 0; i < 4; i++) {
        if (!(stat((this->file_stem + "." + exts[i]).c_str(),  &sb) == 0))
            error->all(FLERR,("Illegal fix fea command, mesh database incomplete, " + (this->file_stem + "." + exts[i]) + " does not exist").c_str());
    }

    // making the elmer class
    this->elmer = new Elmer(std::string(sif_path), this->error);

    // must have " 2>&1" at end to pipe stderr to stdout
    this->command = std::string(exe_path)+" "+std::string(sif_path)+" 2>&1";

    // loading the boundary data
    this->load_boundary();

    // getting the sif file format from the provided
    this->load_sif(std::string(sif_path));


            class ConfigParser {
                public:
                    ConfigParser(std::string _file_name, Error*& _error, bool ignore_var_name_case = true);
                    std::size_t size();
                    std::pair<std::string, std::string> &operator[](int i);

                private:
                    Error* error;
                    std::string file_name;
                    std::vector<std::pair<std::string, std::string>> contents;
                    
                    void read_file(bool ignore_var_name_case = true);
            };


/**
 * Constructor, sets config file and reads it in
*/
FixFea::ConfigParser::ConfigParser(std::string _file_name, Error*& _error, bool ignore_var_name_case) {
    // referencing error
    this->error = _error;

    // making sure the config path exists
    struct stat sb;
    if (!(stat(_file_name.c_str(),  &sb) == 0))
        this->error->all(FLERR, "fix fea config path does not exist");

    this->file_name = _file_name;
    
    // loading the config file
    this->read_file();
}

/**
 * overloading [] to access the class vector while keeping it private
*/
std::pair<std::string, std::string> &FixFea::ConfigParser::operator[](int index) {
    return this->contents[index];
}

/**
 * returns the size of the class vector
*/
std::size_t FixFea::ConfigParser::size() {
    return this->contents.size();
}

/**
 * reads the config file
*/
void FixFea::ConfigParser::read_file(bool ignore_var_name_case) {
    // opening the config file
    std::ifstream file;
    file.open(this->file_name);

    // making sure the file is open, throws error if it isn't
    if (file.is_open()) {
        // temporary variables used in reading data
        std::vector<std::string> lines;
        std::stringstream buffer;
        std::vector<std::string> v;
        std::pair<std::string, std::string> temp;

        // counts line numbers
        int count = 0;

        // reading the file
        buffer << file.rdbuf();

        // splitting the file contents at newlines
        boost::split(lines, buffer.str(), boost::is_any_of("\n"));
        
        // clearing vars for good measure
        buffer.clear();
        this->contents.clear();

        for (std::string line : lines) {
            // trimming whitespaces off of the line
            boost::algorithm::trim(line);

            // filters empty lines
            if (!(line.length()) || line[0] == '#') continue;

            // splitting the line at spaces
            boost::split(v, line, boost::is_any_of(" "));

            // removing empty strings from vector
            for (unsigned int i = 0; i < v.size(); i++) {
                if ( v.at(i) == "" ) {
                    //remove element if empty string
                    v.erase(v.begin() + i);
                    i--;
                }
            }

            // making sure line is valid
            if (v.size() != 2)
                this->error->all(FLERR, ("fix fea config line " + std::to_string(count+1) + " invalid").c_str());
            
            // cleaning up the args
            boost::algorithm::trim(v[0]); boost::algorithm::trim(v[1]);
            
            // if case insensitive for the variable names
            if (ignore_var_name_case) boost::algorithm::to_lower(v[0]);
            
            // adding the arguments
            temp.first = v[0]; temp.second = v[1];

            // adding to class content vector
            this->contents.push_back(temp);
            count++;
        }
    } else this->error->all(FLERR, "fix fea config file did not open");
}
