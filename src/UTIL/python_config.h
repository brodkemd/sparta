#ifndef PYTHON_CONFIG_H
#define PYTHON_CONFIG_H

#include <Python.h>

#define PYTHON_STRING "from tomli import load\nimport os\n\ndef get_from_file(_file) -> dict:\n    with open(_file, 'rb') as f: return load(f)\n\ndata = {}\nrecurse_num = 0\nmax_recurse = 10\nstrict = True\nkeys = {\n    \"HOME\" : os.path.expanduser('~'),\n    \"PWD\"  : os.getcwd()\n}\n\ndef error(_msg:str):\n    if strict: raise Exception(_msg)\n\ndef get_arr(_data, _name:str):\n    start_char = \"[\"\n    end_char   = \"]\"\n    if start_char in _name:\n        _data = _data[_name[:_name.find(start_char)]]\n        for i in range(_name.count(start_char)):\n            index = int(_name[_name.find(start_char)+len(start_char): _name.find(end_char)].strip())\n            if not isinstance(_data, list):\n                error(\"can not index list: \" + _name)\n            try: _data = _data[index]\n            except IndexError as e: error(str(e))\n            _name = _name[_name.find(end_char)+len(end_char):]\n    return _data, _name\n\ndef get_from(_data:dict, _path:str, _orig_path:str=None):\n    \n    if _orig_path is None: _orig_path = _path\n    sep = \".\"\n    \n    if _path in keys:\n        return keys[_path]\n    \n    if sep in _path:\n        _name = _path[:_path.find(sep)]\n        _data, _name = get_arr(_data, _name)\n        # print(\"name:\", _name)\n        if len(_name) == 0: return get_from(_data, _path[_path.find(sep)+len(sep):], _orig_path)\n        elif _name in _data: return get_from(_data[_name], _path[_path.find(sep)+len(sep):], _orig_path)\n        else: error(\"can not resolve path, \" + _orig_path)\n    else:\n        _data, _path = get_arr(_data, _path)\n        if len(_path) == 0: # this means is it an array value\n            return resolve_name(_data)\n        elif _path in _data:\n            if isinstance(_data[_path], str): _data[_path] = resolve_name(_data[_path])\n            return _data[_path]\n        else: error(\"can not resolve path, \" + _orig_path)\n\ndef resolve_name(_name:str):\n    global data, recurse_num, max_recurse\n    if recurse_num > max_recurse:\n        error(f\"reached max allowed recursion resolving {_name} (there is probably a circular definition somewhere)\")\n    start = \"$(\"\n    end   = \")\"\n    while _name.count(start):\n        recurse_num+=1\n        key = _name[_name.find(start)+len(start):_name.find(end, _name.find(start)+len(start))]\n        _name = _name[:_name.find(start)] + str(get_from(data, key)) + _name[_name.find(end, _name.find(start)+len(start)) + len(end):]\n    return _name\n\ndef iter(_data):\n    global recurse_num\n    for item in _data:\n        recurse_num = 0\n        if isinstance(_data[item], dict): iter(_data[item])\n        else:\n            if isinstance(_data[item], list):\n                str_indicies = []\n                for i, val in enumerate(_data[item]):\n                    if isinstance(val, str): str_indicies.append(i)\n                for i in range(len(_data[item])):\n                    val = _data[item][i]\n                    if isinstance(val, str):\n                        _data[item][i] = resolve_name(val)\n                        if _data[item][i] != val:\n                            if i in str_indicies: str_indicies.remove(i)\n                if len(str_indicies):\n                    for i, val in enumerate(_data[item]): _data[item][i] = str(val)\n            elif isinstance(_data[item], str): _data[item] = resolve_name(_data[item])\n\ndef get_at_path(_path):\n    global data\n    return get_from(data, _path)\n\ndef Main(_file):\n    global data\n    data = get_from_file(_file)\n    iter(data)"

#endif